package com.cracker.udfm.core;

import com.cracker.udfm.DalManager;
import com.cracker.udfm.annotations.Column;
import com.cracker.udfm.annotations.GeneratedValue;
import com.cracker.udfm.annotations.Id;
import com.cracker.udfm.annotations.Table;
import com.cracker.udfm.exception.DalException;
import org.bson.types.Binary;
import org.bson.types.ObjectId;



import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;
import java.util.regex.Pattern;

/**
 * 目标元数据信息
 *
 * @author lizh<2486479615@qq.com>
 * <br/>========================================
 * <br/>公司：myself
 * <br/>开发时间：2022-07-05
 * <br/>版本：1.1.0
 * <br/>JDK版本：1.8
 * <br/>========================================
 */
public final class Entity {
    /**
     * 包名 + 类名
     */
    private String fullName;
    /**
     * 包名
     */
    private String packageName;
    /**
     * 类名
     */
    private String className;
    /**
     * 表名
     */
    private String tableName;
    /**
     * 是否做了row缓存
     */
    private boolean isRowCache;
    /**
     * 是否开启row缓存
     */
    private boolean isCacheEnabled;
    /**
     * 类元数据
     */
    private Class<?> classMeta;


    /**
     * _id
     */
    private EntityField idEntityField;

    /**
     * 主键索引
     */
    private StoreIndex index;

    /**
     * 是否自增实体
     */
    private boolean isAutoGenerated = false;


    /**
     * 自增字段实体
     */
    private EntityField autoGeneratedField;

    private List<EntityField> fieldList = new ArrayList();

    /**
     * Field集合，fieldName为key
     */
    private Map<String, EntityField> decFieldMap = new HashMap<>();

    /**
     * Field集合，storage key为key
     */
    private Map<String, EntityField> storeFieldMap = new HashMap<>();

    /**
     * StoreIndex集合
     */
    private Map<String, StoreIndex> indexes = new HashMap<>();

    public String getFullName() {
        return fullName;
    }

    public void setFullName(String fullName) {
        this.fullName = fullName;
    }

    public String getPackageName() {
        return packageName;
    }

    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    public String getClassName() {
        return className;
    }

    public void setClassName(String className) {
        this.className = className;
    }

    public String getTableName() {
        return tableName;
    }

    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    public EntityField getIdEntityField() {
        return idEntityField;
    }

    public void setIdEntityField(EntityField idEntityField) {
        this.idEntityField = idEntityField;
    }

    public boolean isAutoGenerated() {
        return isAutoGenerated;
    }

    public void setAutoGenerated(boolean autoGenerated) {
        isAutoGenerated = autoGenerated;
    }

    public EntityField getAutoGeneratedField() {
        return autoGeneratedField;
    }

    public void setAutoGeneratedField(EntityField autoGeneratedField) {
        this.autoGeneratedField = autoGeneratedField;
    }

    /**
     * 加载实体类，目前暂时不支持继承和内部类
     * @param packageName 包路径
     * @param className 类名
     * @return 0 means ok，1 means fail
     */
    public int loadClass(String packageName, String className) {
        setPackageName(packageName);
        setClassName(className);
        setFullName(packageName + "." + className);

        try {
            this.classMeta = Class.forName(this.fullName);
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
            return 1;
        }

        if (!this.classMeta.isAnnotationPresent(Table.class)) {
            String errorMsg = "Miss @Table: " + packageName + "." + className;
            DalException er = new DalException(errorMsg);
            er.logError(er, errorMsg);
            throw er;
        }
        Table table = this.classMeta.getAnnotation(Table.class);
        if (table != null) {
            this.setTableName(table.name());
        }

        // 获取所有的存储字段
        boolean pkFlag = false;

        Field[] fields = this.classMeta.getDeclaredFields();
        for (Field field : fields) {
            // 设置field的访问权限
            field.setAccessible(true);
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                if (column != null) {
                    EntityField entityField = new EntityField();
                    entityField.setMotherClass(this);
                    entityField.setFieldMeta(field);
                    entityField.setColumnName(column.name());
                    entityField.setDbType(column.type());
                    entityField.setStoreNull(column.isStoreNull());
                    entityField.setAutoIncrease(column.isAutoIncrease());

                    this.decFieldMap.put(field.getName(), entityField);
                    this.storeFieldMap.put(column.name(), entityField);
                    this.fieldList.add(entityField);

                    // 主键检查
                    if (field.isAnnotationPresent(Id.class)) {

                        if (pkFlag) {
                            // ORM异常
                            String errorMsg = "repeated @Id";
                            DalException error = new DalException();
                            error.logError(error, errorMsg);
                            throw error;
                        }
                        pkFlag = true;
                        entityField.setId(true);


                        // 实体类添加主键pk字段
                        this.setIdEntityField(entityField);

                        // 自增Id判断
                        if (field.isAnnotationPresent(GeneratedValue.class)) {

                            entityField.setAutoIncrease(true);
                            this.setAutoGenerated(true);
                            this.setAutoGeneratedField(entityField);

                        }
                    } else {
                        if (field.isAnnotationPresent(GeneratedValue.class)) {
                            String errorMsg = String.format("auto generate field must be @Id: %s", field.getName());
                            DalException error = new DalException(errorMsg);
                            error.logError(error, errorMsg);
                            throw error;
                        }
                    }
                    if (this.loadFieldClass(entityField) != 0) {
                        return 1;
                    }
                }
            }
        }
        // 测试可删
        return 1;
    }

    /**
     * 加载FieldClass
     * @param field 字段实体
     * @return 0 表示 success，1 表示 fail
     */
    private int loadFieldClass(EntityField field) {

        Class<?> fieldClass;
        Class<?> subClass = null;

        if (field == null || field.getFieldMeta() == null) {
            String errorMsg = "EntityField and FieldMeta must not be null";
            DalException err = new DalException(errorMsg);
            err.logError(err, errorMsg);
            throw err;
        }
        if (isClassLoadKnowEnd(fieldClass = field.getFieldMeta().getType())) {
            field.setDecType(DataFieldType.ATOM);
            return 0;
        }
        if (Collection.class.isAssignableFrom(fieldClass)) {
            field.setDecType(DataFieldType.COLLECTION);
            // 得到泛型类型
            Type type = field.getFieldMeta().getGenericType();
            ParameterizedType pt = (ParameterizedType) type;
            Type[] types = pt.getActualTypeArguments();

            subClass = (Class<?>) (types[0]);

        } else if (Map.class.isAssignableFrom(fieldClass)) {
            field.setDecType(DataFieldType.MAP);
            // 得到泛型类型
            Type type = field.getFieldMeta().getGenericType();
            ParameterizedType pt = (ParameterizedType) type;

            Type[] types = pt.getActualTypeArguments();

            if (!types[0].equals(String.class)) {
                return 1;
            }

            if (types[1] != null && types[1] instanceof ParameterizedType) {
                ParameterizedType ptt = (ParameterizedType) types[1];
                subClass = (Class<?>) (ptt.getActualTypeArguments()[0]);
            } else {
                subClass = (Class<?>) types[1];
            }
        } else if (fieldClass.isArray()) {
            field.setDecType(DataFieldType.ARRAY);
            subClass = fieldClass.getComponentType();
        }
        // 对于集合类型的对象
        if (subClass != null) {
            if (isClassLoadKnowEnd(subClass)) {
                return 0;
            }

            Entity newDataClass = DalManager.getInstance().getDataClass(subClass.getName());
            // the class has been loaded, return ok
            if (newDataClass != null) {
                field.setSubClass(newDataClass);
                return 0;
            }

            newDataClass = new Entity();
            newDataClass.setFullName(subClass.getName());

            // add first avoiding recall
            DalManager.getInstance().addDataClass(newDataClass);

            if (newDataClass.loadClass(subClass.getPackage().getName(), subClass.getSimpleName()) != 0) {
                // 测试可删
                //DalManager.getInstance().r
            }

        }

        return 1;

    }

    /**
     * 判断字段所属类型
     * @param theClass 字段对应的Class
     * @return boolean
     */
    public static boolean isClassLoadKnowEnd(Class<?> theClass) {
        if (theClass == null) {
            return false;
        }

        return theClass.isPrimitive()
                || theClass.isAssignableFrom(String.class)
                || theClass.isAssignableFrom(ObjectId.class)
                || theClass.isAssignableFrom(Short.class)
                || theClass.isAssignableFrom(Byte.class)
                || theClass.isAssignableFrom(Integer.class)
                || theClass.isAssignableFrom(Long.class)
                || theClass.isAssignableFrom(Float.class)
                || theClass.isAssignableFrom(Double.class)
                || theClass.isAssignableFrom(Boolean.class)
                || theClass.isAssignableFrom(Character.class)
                || theClass.isAssignableFrom(Number.class)
                || theClass.isAssignableFrom(Date.class)
                || theClass.isAssignableFrom(Pattern.class)
                || theClass.isAssignableFrom(byte[].class)
                || theClass.isAssignableFrom(Binary.class)
                || theClass.isAssignableFrom(UUID.class);
    }

}
